<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Non Fungible Button</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #f0f0f0;
				color: #444;
			}
			a {
				color: #08f;
			}
		</style>
	</head>
	<body>
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			let tRate = 0.5
			let container;
			let camera, scene, raycaster, renderer;

			let INTERSECTED;
			let theta = 0;

			const pointer = new THREE.Vector2();
			const radius = 100;

			let orange = false;
			let orangeLevel = 0;
			let orangeDOM;

			init();
			animate();

			function init() {

				document.addEventListener("click", (e) => {
					if (INTERSECTED && Math.floor(INTERSECTED.position.y) == 0)
					{
						INTERSECTED.position.y = -2
						// console.log(window.location.href)
						alert(orangeLevel)
					}
				})

				container = document.createElement( 'div' );
				orangeDOM = document.createElement( 'div' );
				orangeDOM.className = "orangeDOM"
				container.appendChild( orangeDOM );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.y = 20
				camera.position.z = 50

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );

				const light = new THREE.DirectionalLight( 0xffffff, 1 );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );

				const geometry = new THREE.IcosahedronGeometry( 1, 0 );
				const colors = [
								0xff0000,
								0xff8000,
								0xffff00,
								0x80ff00,
								0x00ff00,
								0x00ff80,
								0x00ffff,
								0x0080ff,
								0x0000ff,
								0x8000ff,
								0xff00ff,
								0xff0080,
								]
				for ( let i = 0; i < 12; i ++ ) {

					const object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: colors[i] } ) );

					object.position.x = (-40*i);
					object.rotation.y = Math.random() * 0.4 * Math.PI + 0.1;
					// object.scale.y = (i * 0.2) + 1;
					object.scale.x = 10
					object.scale.y = 10
					object.scale.z = 10


					scene.add( object );

				}

				raycaster = new THREE.Raycaster();

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				document.addEventListener( 'mousemove', onPointerMove );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onPointerMove( event ) {

				pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
			}

			function render() {
				if (orange)
				{
					let asd = parseInt(INTERSECTED.id)
					orangeLevel += asd
					orangeDOM.innerHTML = orangeLevel
				}

				theta += tRate;
				tRate += 0.0001;

				camera.position.x = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );
				camera.lookAt( scene.position );

				camera.updateMatrixWorld();

				// find intersections

				if (INTERSECTED && INTERSECTED.position.y < 0)
				{
					INTERSECTED.position.y = INTERSECTED.position.y < 0 ? INTERSECTED.position.y + 0.2  : 0
				}

				raycaster.setFromCamera( pointer, camera );

				const intersects = raycaster.intersectObjects( scene.children, false );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED )
						{
							INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
						}

						INTERSECTED = intersects[ 0 ].object;
						if (INTERSECTED.id > 10 && INTERSECTED.id <= 21)
						{
							orange = true
						}
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0x550000 );

					}

				} else {

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					if (orange)
					{
						orangeLevel -= parseInt(orangeLevel / 2)
						orangeDOM.innerHTML = orangeLevel
					}
					orange = false
					
					INTERSECTED = null;

				}

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>