<!DOCTYPE html>
<html lang="en">
	<head>
		<title>3duno</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #f0f0f0;
				color: #444;
			}
			a {
				color: #08f;
			}
		</style>
	</head>
	<body>
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			const lerp = (x, y, a) => x * (1 - a) + y * a;

			let totalTimeElapsed = 0
			let tRate = 0.5
			let container;
			let camera, scene, raycaster, renderer;

			let INTERSECTED;
			let SELECTED;
			let theta = 0;

			const pointer = new THREE.Vector2();
			const radius = 100;

			let orange = false;
			let orangeLevel = 0;
			let orangeDOM;

			let desire = [];

			init();
			animate();

			function init() {

				document.addEventListener("click", (e) => {
					if (INTERSECTED && Math.floor(INTERSECTED.position.y) == 0)
					{
						// INTERSECTED.position.y = -2

						// console.log(window.location.href)
						// alert(orangeLevel)
					}
					if (INTERSECTED) {
						camera.lookAt( INTERSECTED.position );
						SELECTED = {...INTERSECTED}

						if (SELECTED) {

							camera.position.y = SELECTED.position.y + 15
							// camera.position.y = lerp(
							// 	camera.position.y,
							// 	SELECTED.position.y + 15,
							// 	0.5) + Math.sin(totalTimeElapsed/20)/80
							// camera.position.z = SELECTED.position.z + 30
						}
					}
				})

				container = document.createElement( 'div' );
				orangeDOM = document.createElement( 'div' );
				orangeDOM.className = "orangeDOM"
				container.appendChild( orangeDOM );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 110, window.innerWidth / window.innerHeight, 1, 10000 );
				// camera.position.y = 30
				camera.position.z = 50
				camera.lookAt(0,0,0)

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );

				const light = new THREE.DirectionalLight( 0xffffff, 1 );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );

				// const textgeometry = new THREE.TextGeometry( 1, 1, 1 );
				const geometry = new THREE.BoxGeometry( 1, 1, 1 );
				const colors = [
								0xff0000,
								0xff8000,
								0xffff00,
								0x80ff00,
								0x00ff00,
								0x00ff80,
								0x00ffff,
								0x0080ff,
								0x0000ff,
								0x8000ff,
								0xff00ff,
								0xff0080,
								]
				for ( let i = 0; i < 12; i ++ ) {

					const object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: colors[i] } ) );

					object.position.z = (-30*i);
					// object.position.z = Math.cos(i)*75;
					// object.position.x = Math.sin(i)*25;
					// object.position.z = Math.cos(i)*180;
					// object.position.z = -Math.sin(i)*40;
					// object.position.x = Math.sin(i)*75;
					// object.rotation.y = Math.random() * 0.4 * Math.PI + 0.1;
					// object.scale.y = (i * 0.2) + 1;
					object.scale.x = 10
					object.scale.y = 10
					object.scale.z = 10


					scene.add( object );

				}

				raycaster = new THREE.Raycaster();

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );



				document.addEventListener( 'mousemove', onPointerMove );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onPointerMove( event ) {

				pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			//

			function animate() {
				totalTimeElapsed += 1
				requestAnimationFrame( animate );

				render();
			}

			function render() {
				if (orange)
				{
					let asd = parseInt(INTERSECTED.id)
					// camera.position.set( INTERSECTED.position  );

					// camera.position.x = INTERSECTED.position.x
					// camera.lookAt( INTERSECTED.position );
					// camera.position.z = 50
					// camera.position.y = 20
					orangeLevel += asd
					orangeDOM.innerHTML = orangeLevel
				} else {
					// camera.position.x = scene.position.x
					// camera.lookAt( scene.position );
				}

				theta += tRate;
				tRate += 0.0001;

				// camera.position.x = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );
				// camera.lookAt( scene.position );

				camera.updateMatrixWorld();

				// find intersections

				if (INTERSECTED && INTERSECTED.position.y < 0)
				{

					// INTERSECTED.position.y = INTERSECTED.position.y < 0 ? INTERSECTED.position.y + 0.2  : 0
				}

				raycaster.setFromCamera( pointer, camera );

				const intersects = raycaster.intersectObjects( scene.children, false );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED )
						{
							INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
						}

						INTERSECTED = intersects[ 0 ].object;
						if (INTERSECTED.id > 10 && INTERSECTED.id <= 21)
						{
							orange = true
						}
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0x550000 );

					}

				} else {

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					if (orange)
					{
						orangeLevel -= parseInt(orangeLevel / 2)
						orangeDOM.innerHTML = orangeLevel
					}
					orange = false
					
					INTERSECTED = null;

				}

					if (SELECTED) {

						camera.position.y = SELECTED.position.y + 15
						// camera.position.y = lerp(
						// 	camera.position.y,
						// 	SELECTED.position.y + 15,
						// 	0.5) + Math.sin(totalTimeElapsed/20)/80
						// camera.position.z = SELECTED.position.z + 30
						camera.position.z = lerp(
							camera.position.z,
							SELECTED.position.z + 30,
							0.5)
						camera.lookAt( SELECTED.position );
					} else {

					}
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>