<!DOCTYPE html>
<html lang="en">
	<head>
		<title>3duno</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="css/main.css">
		<link type="text/css" rel="stylesheet" href="css/spirit.css">
		<style>
			body {
				background-color: #f0f0f0;
				color: #444;
			}
			a {
				color: #08f;
			}
			.orangeDOM {
				position: fixed;
				top: 0;
				left: 0;
				padding: 10px;
				letter-spacing: 5px;
			}
		</style>
	</head>
	<body>
        <div class="flex-wrap" style="position: fixed; bottom: 0;padding-bottom: 25px">
            <div class="flex-wrap" >
                <button class="ma-0 tx-ls-2 tx-xxl  clickable pa-3 opacity-hover-50 scene-goto" style="text-shadow: 2px 2px #000000,  -2px 2px #00000077; color: #ccc" id="scene1">1</button>
                <button class="ma-0 tx-ls-2 tx-xxl  clickable pa-3 opacity-hover-50 scene-goto" style="text-shadow: 2px 2px #000000,  -2px 2px #00000077; color: #ccc" id="scene2">2</button>
                <button class="ma-0 tx-ls-2 tx-xxl  clickable pa-3 opacity-hover-50 scene-goto" style="text-shadow: 2px 2px #000000,  -2px 2px #00000077; color: #ccc" id="scene3">3</button>
                <button class="ma-0 tx-ls-2 tx-xxl  clickable pa-3 opacity-hover-50 scene-goto" style="text-shadow: 2px 2px #000000,  -2px 2px #00000077; color: #ccc" id="scene4">4</button>
                <button class="ma-0 tx-ls-2 tx-xxl  clickable pa-3 opacity-hover-50 scene-goto" style="text-shadow: 2px 2px #000000,  -2px 2px #00000077; color: #ccc" id="scene5">5</button>
                <button class="ma-0 tx-ls-2 tx-xxl  clickable pa-3 opacity-hover-50 scene-goto" style="text-shadow: 2px 2px #000000,  -2px 2px #00000077; color: #ccc" id="scene6">6</button>
            </div>
            <div class="flex-wrap" >
                <button class="ma-0 tx-ls-2 tx-xxl  clickable pa-3 opacity-hover-50 scene-goto" style="text-shadow: 2px 2px #000000,  -2px 2px #00000077; color: #ccc" id="scene7">7</button>
                <button class="ma-0 tx-ls-2 tx-xxl  clickable pa-3 opacity-hover-50 scene-goto" style="text-shadow: 2px 2px #000000,  -2px 2px #00000077; color: #ccc" id="scene8">8</button>
                <button class="ma-0 tx-ls-2 tx-xxl  clickable pa-3 opacity-hover-50 scene-goto" style="text-shadow: 2px 2px #000000,  -2px 2px #00000077; color: #ccc" id="scene9">9</button>
                <button class="ma-0 tx-ls-2 tx-xxl  clickable pa-3 opacity-hover-50 scene-goto" style="text-shadow: 2px 2px #000000,  -2px 2px #00000077; color: #ccc" id="scene10">10</button>
                <button class="ma-0 tx-ls-2 tx-xxl  clickable pa-3 opacity-hover-50 scene-goto" style="text-shadow: 2px 2px #000000,  -2px 2px #00000077; color: #ccc" id="scene11">11</button>
                <button class="ma-0 tx-ls-2 tx-xxl  clickable pa-3 opacity-hover-50 scene-goto" style="text-shadow: 2px 2px #000000,  -2px 2px #00000077; color: #ccc" id="scene12">12</button>
            </div>
        </div>
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

let THREE_OBJLoader = function(manager) {

    this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;

    this.materials = null;

    this.regexp = {
        // v float float float
        vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // vn float float float
        normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // vt float float
        uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // f vertex vertex vertex
        face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
        // f vertex/uv vertex/uv vertex/uv
        face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
        // f vertex/uv/normal vertex/uv/normal vertex/uv/normal
        face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
        // f vertex//normal vertex//normal vertex//normal
        face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
        // o object_name | g group_name
        object_pattern: /^[og]\s*(.+)?/,
        // s boolean
        smoothing_pattern: /^s\s+(\d+|on|off)/,
        // mtllib file_reference
        material_library_pattern: /^mtllib /,
        // usemtl material_name
        material_use_pattern: /^usemtl /
    };

};

THREE_OBJLoader.prototype = {

    constructor: THREE_OBJLoader,

    load: function(url, onLoad, onProgress, onError) {

        var scope = this;

        var loader = new THREE.XHRLoader(scope.manager);
        loader.setPath(this.path);
        loader.load(url, function(text) {

            onLoad(scope.parse(text));

        }, onProgress, onError);

    },

    setPath: function(value) {

        this.path = value;

    },

    setMaterials: function(materials) {

        this.materials = materials;

    },

    _createParserState: function() {

        var state = {
            objects: [],
            object: {},

            vertices: [],
            normals: [],
            uvs: [],

            materialLibraries: [],

            startObject: function(name, fromDeclaration) {

                // If the current object (initial from reset) is not from a g/o declaration in the parsed
                // file. We need to use it for the first parsed g/o to keep things in sync.
                if (this.object && this.object.fromDeclaration === false) {

                    this.object.name = name;
                    this.object.fromDeclaration = (fromDeclaration !== false);
                    return;

                }

                if (this.object && typeof this.object._finalize === 'function') {

                    this.object._finalize();

                }

                var previousMaterial = (this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined);

                this.object = {
                    name: name || '',
                    fromDeclaration: (fromDeclaration !== false),

                    geometry: {
                        vertices: [],
                        normals: [],
                        uvs: []
                    },
                    materials: [],
                    smooth: true,

                    startMaterial: function(name, libraries) {

                        var previous = this._finalize(false);

                        // New usemtl declaration overwrites an inherited material, except if faces were declared
                        // after the material, then it must be preserved for proper MultiMaterial continuation.
                        if (previous && (previous.inherited || previous.groupCount <= 0)) {

                            this.materials.splice(previous.index, 1);

                        }

                        var material = {
                            index: this.materials.length,
                            name: name || '',
                            mtllib: (Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : ''),
                            smooth: (previous !== undefined ? previous.smooth : this.smooth),
                            groupStart: (previous !== undefined ? previous.groupEnd : 0),
                            groupEnd: -1,
                            groupCount: -1,
                            inherited: false,

                            clone: function(index) {
                                return {
                                    index: (typeof index === 'number' ? index : this.index),
                                    name: this.name,
                                    mtllib: this.mtllib,
                                    smooth: this.smooth,
                                    groupStart: this.groupEnd,
                                    groupEnd: -1,
                                    groupCount: -1,
                                    inherited: false
                                };
                            }
                        };

                        this.materials.push(material);

                        return material;

                    },

                    currentMaterial: function() {

                        if (this.materials.length > 0) {
                            return this.materials[this.materials.length - 1];
                        }

                        return undefined;

                    },

                    _finalize: function(end) {

                        var lastMultiMaterial = this.currentMaterial();
                        if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {

                            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                            lastMultiMaterial.inherited = false;

                        }

                        // Guarantee at least one empty material, this makes the creation later more straight forward.
                        if (end !== false && this.materials.length === 0) {
                            this.materials.push({
                                name: '',
                                smooth: this.smooth
                            });
                        }

                        return lastMultiMaterial;

                    }
                };

                // Inherit previous objects material.
                // Spec tells us that a declared material must be set to all objects until a new material is declared.
                // If a usemtl declaration is encountered while this new object is being parsed, it will
                // overwrite the inherited material. Exception being that there was already face declarations
                // to the inherited material, then it will be preserved for proper MultiMaterial continuation.

                if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {

                    var declared = previousMaterial.clone(0);
                    declared.inherited = true;
                    this.object.materials.push(declared);

                }

                this.objects.push(this.object);

            },

            finalize: function() {

                if (this.object && typeof this.object._finalize === 'function') {

                    this.object._finalize();

                }

            },

            parseVertexIndex: function(value, len) {

                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 3) * 3;

            },

            parseNormalIndex: function(value, len) {

                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 3) * 3;

            },

            parseUVIndex: function(value, len) {

                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 2) * 2;

            },

            addVertex: function(a, b, c) {

                var src = this.vertices;
                var dst = this.object.geometry.vertices;

                dst.push(src[a + 0]);
                dst.push(src[a + 1]);
                dst.push(src[a + 2]);
                dst.push(src[b + 0]);
                dst.push(src[b + 1]);
                dst.push(src[b + 2]);
                dst.push(src[c + 0]);
                dst.push(src[c + 1]);
                dst.push(src[c + 2]);

            },

            addVertexLine: function(a) {

                var src = this.vertices;
                var dst = this.object.geometry.vertices;

                dst.push(src[a + 0]);
                dst.push(src[a + 1]);
                dst.push(src[a + 2]);

            },

            addNormal: function(a, b, c) {

                var src = this.normals;
                var dst = this.object.geometry.normals;

                dst.push(src[a + 0]);
                dst.push(src[a + 1]);
                dst.push(src[a + 2]);
                dst.push(src[b + 0]);
                dst.push(src[b + 1]);
                dst.push(src[b + 2]);
                dst.push(src[c + 0]);
                dst.push(src[c + 1]);
                dst.push(src[c + 2]);

            },

            addUV: function(a, b, c) {

                var src = this.uvs;
                var dst = this.object.geometry.uvs;

                dst.push(src[a + 0]);
                dst.push(src[a + 1]);
                dst.push(src[b + 0]);
                dst.push(src[b + 1]);
                dst.push(src[c + 0]);
                dst.push(src[c + 1]);

            },

            addUVLine: function(a) {

                var src = this.uvs;
                var dst = this.object.geometry.uvs;

                dst.push(src[a + 0]);
                dst.push(src[a + 1]);

            },

            addFace: function(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {

                var vLen = this.vertices.length;

                var ia = this.parseVertexIndex(a, vLen);
                var ib = this.parseVertexIndex(b, vLen);
                var ic = this.parseVertexIndex(c, vLen);
                var id;

                if (d === undefined) {

                    this.addVertex(ia, ib, ic);

                } else {

                    id = this.parseVertexIndex(d, vLen);

                    this.addVertex(ia, ib, id);
                    this.addVertex(ib, ic, id);

                }

                if (ua !== undefined) {

                    var uvLen = this.uvs.length;

                    ia = this.parseUVIndex(ua, uvLen);
                    ib = this.parseUVIndex(ub, uvLen);
                    ic = this.parseUVIndex(uc, uvLen);

                    if (d === undefined) {

                        this.addUV(ia, ib, ic);

                    } else {

                        id = this.parseUVIndex(ud, uvLen);

                        this.addUV(ia, ib, id);
                        this.addUV(ib, ic, id);

                    }

                }

                if (na !== undefined) {

                    // Normals are many times the same. If so, skip function call and parseInt.
                    var nLen = this.normals.length;
                    ia = this.parseNormalIndex(na, nLen);

                    ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
                    ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);

                    if (d === undefined) {

                        this.addNormal(ia, ib, ic);

                    } else {

                        id = this.parseNormalIndex(nd, nLen);

                        this.addNormal(ia, ib, id);
                        this.addNormal(ib, ic, id);

                    }

                }

            },

            addLineGeometry: function(vertices, uvs) {

                this.object.geometry.type = 'Line';

                var vLen = this.vertices.length;
                var uvLen = this.uvs.length;

                for (var vi = 0, l = vertices.length; vi < l; vi++) {

                    this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));

                }

                for (var uvi = 0, l = uvs.length; uvi < l; uvi++) {

                    this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));

                }

            }

        };

        state.startObject('', false);

        return state;

    },

    parse: function(text) {

        console.time('OBJLoader');

        var state = this._createParserState();

        if (text.indexOf('\r\n') !== -1) {

            // This is faster than String.split with regex that splits on both
            text = text.replace('\r\n', '\n');

        }

        var lines = text.split('\n');
        var line = '',
            lineFirstChar = '',
            lineSecondChar = '';
        var lineLength = 0;
        var result = [];

        // Faster to just trim left side of the line. Use if available.
        var trimLeft = (typeof ''.trimLeft === 'function');

        for (var i = 0, l = lines.length; i < l; i++) {

            line = lines[i];

            line = trimLeft ? line.trimLeft() : line.trim();

            lineLength = line.length;

            if (lineLength === 0) continue;

            lineFirstChar = line.charAt(0);

            // @todo invoke passed in handler if any
            if (lineFirstChar === '#') continue;

            if (lineFirstChar === 'v') {

                lineSecondChar = line.charAt(1);

                if (lineSecondChar === ' ' && (result = this.regexp.vertex_pattern.exec(line)) !== null) {

                    // 0                  1      2      3
                    // ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

                    state.vertices.push(
                    parseFloat(result[1]),
                    parseFloat(result[2]),
                    parseFloat(result[3]));

                } else if (lineSecondChar === 'n' && (result = this.regexp.normal_pattern.exec(line)) !== null) {

                    // 0                   1      2      3
                    // ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

                    state.normals.push(
                    parseFloat(result[1]),
                    parseFloat(result[2]),
                    parseFloat(result[3]));

                } else if (lineSecondChar === 't' && (result = this.regexp.uv_pattern.exec(line)) !== null) {

                    // 0               1      2
                    // ["vt 0.1 0.2", "0.1", "0.2"]

                    state.uvs.push(
                    parseFloat(result[1]),
                    parseFloat(result[2]));

                } else {

                    throw new Error("Unexpected vertex/normal/uv line: '" + line + "'");

                }

            } else if (lineFirstChar === "f") {

                if ((result = this.regexp.face_vertex_uv_normal.exec(line)) !== null) {

                    // f vertex/uv/normal vertex/uv/normal vertex/uv/normal
                    // 0                        1    2    3    4    5    6    7    8    9   10         11         12
                    // ["f 1/1/1 2/2/2 3/3/3", "1", "1", "1", "2", "2", "2", "3", "3", "3", undefined, undefined, undefined]

                    state.addFace(
                    result[1], result[4], result[7], result[10],
                    result[2], result[5], result[8], result[11],
                    result[3], result[6], result[9], result[12]);

                } else if ((result = this.regexp.face_vertex_uv.exec(line)) !== null) {

                    // f vertex/uv vertex/uv vertex/uv
                    // 0                  1    2    3    4    5    6   7          8
                    // ["f 1/1 2/2 3/3", "1", "1", "2", "2", "3", "3", undefined, undefined]

                    state.addFace(
                    result[1], result[3], result[5], result[7],
                    result[2], result[4], result[6], result[8]);

                } else if ((result = this.regexp.face_vertex_normal.exec(line)) !== null) {

                    // f vertex//normal vertex//normal vertex//normal
                    // 0                     1    2    3    4    5    6   7          8
                    // ["f 1//1 2//2 3//3", "1", "1", "2", "2", "3", "3", undefined, undefined]

                    state.addFace(
                    result[1], result[3], result[5], result[7],
                    undefined, undefined, undefined, undefined,
                    result[2], result[4], result[6], result[8]);

                } else if ((result = this.regexp.face_vertex.exec(line)) !== null) {

                    // f vertex vertex vertex
                    // 0            1    2    3   4
                    // ["f 1 2 3", "1", "2", "3", undefined]

                    state.addFace(
                    result[1], result[2], result[3], result[4]);

                } else {

                    throw new Error("Unexpected face line: '" + line + "'");

                }

            } else if (lineFirstChar === "l") {

                var lineParts = line.substring(1).trim().split(" ");
                var lineVertices = [],
                    lineUVs = [];

                if (line.indexOf("/") === -1) {

                    lineVertices = lineParts;

                } else {

                    for (var li = 0, llen = lineParts.length; li < llen; li++) {

                        var parts = lineParts[li].split("/");

                        if (parts[0] !== "") lineVertices.push(parts[0]);
                        if (parts[1] !== "") lineUVs.push(parts[1]);

                    }

                }
                state.addLineGeometry(lineVertices, lineUVs);

            } else if ((result = this.regexp.object_pattern.exec(line)) !== null) {

                // o object_name
                // or
                // g group_name

                var name = result[0].substr(1).trim();
                state.startObject(name);

            } else if (this.regexp.material_use_pattern.test(line)) {

                // material

                state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);

            } else if (this.regexp.material_library_pattern.test(line)) {

                // mtl file

                state.materialLibraries.push(line.substring(7).trim());

            } else if ((result = this.regexp.smoothing_pattern.exec(line)) !== null) {

                // smooth shading

                // @todo Handle files that have varying smooth values for a set of faces inside one geometry,
                // but does not define a usemtl for each face set.
                // This should be detected and a dummy material created (later MultiMaterial and geometry groups).
                // This requires some care to not create extra material on each smooth value for "normal" obj files.
                // where explicit usemtl defines geometry groups.
                // Example asset: examples/models/obj/cerberus/Cerberus.obj

                var value = result[1].trim().toLowerCase();
                state.object.smooth = (value === '1' || value === 'on');

                var material = state.object.currentMaterial();
                if (material) {

                    material.smooth = state.object.smooth;

                }

            } else {

                // Handle null terminated files without exception
                if (line === '\0') continue;

                throw new Error("Unexpected line: '" + line + "'");

            }

        }

        state.finalize();

        var container = new THREE.Group();
        container.materialLibraries = [].concat(state.materialLibraries);

        for (var i = 0, l = state.objects.length; i < l; i++) {

            var object = state.objects[i];
            var geometry = object.geometry;
            var materials = object.materials;
            var isLine = (geometry.type === 'Line');

            // Skip o/g line declarations that did not follow with any faces
            if (geometry.vertices.length === 0) continue;

            var buffergeometry = new THREE.BufferGeometry();

            buffergeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(geometry.vertices), 3));

            if (geometry.normals.length > 0) {

                buffergeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(geometry.normals), 3));

            } else {

                buffergeometry.computeVertexNormals();

            }

            if (geometry.uvs.length > 0) {

                buffergeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(geometry.uvs), 2));

            }

            // Create materials

            var createdMaterials = [];

            for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {

                var sourceMaterial = materials[mi];
                var material = undefined;

                if (this.materials !== null) {

                    material = this.materials.create(sourceMaterial.name);

                    // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
                    if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {

                        var materialLine = new THREE.LineBasicMaterial();
                        materialLine.copy(material);
                        material = materialLine;

                    }

                }

                if (!material) {

                    material = (!isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial());
                    material.name = sourceMaterial.name;

                }

                material.shading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading;

                createdMaterials.push(material);

            }

            // Create mesh

            var mesh;

            if (createdMaterials.length > 1) {

                for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {

                    var sourceMaterial = materials[mi];
                    buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);

                }

                var multiMaterial = new THREE.MultiMaterial(createdMaterials);
                mesh = (!isLine ? new THREE.Mesh(buffergeometry, multiMaterial) : new THREE.Line(buffergeometry, multiMaterial));

            } else {

                mesh = (!isLine ? new THREE.Mesh(buffergeometry, createdMaterials[0]) : new THREE.Line(buffergeometry, createdMaterials[0]));
            }

            mesh.name = object.name;

            container.add(mesh);

        }

        console.timeEnd('OBJLoader');

        return container;

    }

}; 






























			const lerp = (x, y, a) => x * (1 - a) + y * a;

			let totalTimeElapsed = 0
			let tRate = 0.5
			let container;
			let camera, scene, raycaster, renderer;

			let INTERSECTED;
			let colors;
            let SELECTED;
			let light;
			let theta = 0;

			const pointer = new THREE.Vector2();
			const radius = 100;

			let orange = false;
			let orangeLevel = 0;
			let orangeDOM;

			let desire = [];

			init();
			animate();

			function init() {
                var sceness = document.querySelectorAll('.scene-goto')
                sceness.forEach(function(adomscene) {
                  // adomscene is the current element
                  adomscene.onclick = function(e) {
                    SELECTED = scene.children[parseInt(e.currentTarget.id.replace("scene",""))+1]
                        camera.lookAt( SELECTED.position );
                    // $('.item').removeClass('scene-carousel-fix');
                    // $('.scene-backdrop').css('display','none')
                    // $('.quickview-scene').css('display','none');
                    // $(this).parent().closest('.carousel-inner').css('overflow', 'hidden');
                  }
                });
                // document.getElementById("scene2").addEventListener("click", (e) => {
                //     console.log(scene.children)
                //     SELECTED = scene.children[5]
                // })
				document.addEventListener("click", (e) => {
					if (INTERSECTED && Math.floor(INTERSECTED.position.y) == 0)
					{
						// INTERSECTED.position.y = -2

						// console.log(window.location.href)
						// alert(orangeLevel)
					}
					if (INTERSECTED) {
						// camera.lookAt( INTERSECTED.position );
						// SELECTED = {...INTERSECTED}

						if (SELECTED) {
							// console.log(SELECTED.position.z/30)

							camera.position.y = SELECTED.position.y + 15
							// camera.position.y = lerp(
							// 	camera.position.y,
							// 	SELECTED.position.y + 15,
							// 	0.5) + Math.sin(totalTimeElapsed/20)/80
							// camera.position.z = SELECTED.position.z + 30
						}
					}
				})

				container = document.createElement( 'div' );
				orangeDOM = document.createElement( 'div' );
				orangeDOM.className = "orangeDOM"
				container.appendChild( orangeDOM );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 120, window.innerWidth / window.innerHeight, 1, 10000 );
				// camera.position.y = 30
				camera.position.z = 50
				camera.lookAt(0,0,0)

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );

				light = new THREE.PointLight( 0xffffff, 1, 100 );
    light.position.set( 0, 10, 20 );
    light.castShadow = true;            // default false
    scene.add( light );

    var ambientLight = new THREE.AmbientLight(0xffffff, 0.25);
    scene.add(ambientLight);

				colors = [
                                {img:"img/grad1.jpg",wireframe:false,camera:{pos:[0 ,0,25]},color:0xff9999,},
                                {img:"img/grad1.jpg",wireframe:true,camera:{pos:[40 ,5,-27]},color:0xff9999,},
								{img:"img/grad1.jpg",wireframe:false,camera:{pos:[0 ,-5,0]},color:0xffcc99,},
								{img:"img/grad1.jpg",wireframe:false,camera:{pos:[-25,-15,-10]},color:0xffff99,},
								{img:"img/grad1.jpg",wireframe:false,camera:{pos:[-30,10,-20]},color:0xccff99,},
								{img:"img/grad1.jpg",wireframe:true,camera:{pos:[0,  15,-10]},color:0x99ff99,},
								{img:"img/grad1.jpg",wireframe:false,camera:{pos:[0,  20,0]},color:0x99ffcc,},
								{img:"img/grad1.jpg",wireframe:false,camera:{pos:[0,  5,0]},color:0x99ffff,},
								{img:"img/grad1.jpg",wireframe:false,camera:{pos:[0,  -8,0]},color:0x99ccff,},
								{img:"img/grad1.jpg",wireframe:true,camera:{pos:[0,  5,0]},color:0x9999ff,},
								{img:"img/grad1.jpg",wireframe:false,camera:{pos:[0,  -35,15]},color:0xcc99ff,},
								{img:"img/grad1.jpg",wireframe:false,camera:{pos:[0,  5,0]},color:0xff99ff,},
								{img:"img/grad1.jpg",wireframe:false,camera:{pos:[0,  50,0]},color:0xff99cc,}
								]

				var objloader = new THREE_OBJLoader();
				let teslaT;
				objloader.load( './models/camera.obj', function ( object ) {
				  // Store.state.scene.add( cube );
			   //    object.rotation.z = Math.PI;
			      object.scale.set(6,6,6)
			   		console.log(object)
			   		// object.rotation.x += Math.PI / 2
			   		// object.rotation.y += Math.PI / 2
			   		// object.rotation.y = Math.PI / 2
                    object.position.x = 20
			   		object.position.z = -90
			   		object.position.y = -11
			   		object.castShadow = true

					// let material = new THREE.MeshLambertMaterial({ color: 0xffaa00 });

                    object.traverse( function (child)
                    {
                        if ( child instanceof THREE.Mesh )
                        {
                            child.material = new THREE.MeshLambertMaterial({ color: 0xffaa00 })
                        }
                    });
					// teslaT = new THREE.Mesh( object, material );
					// teslaT = object
			        scene.add( object );
			      // document.querySelector('h1').style.display = 'none';
			    } );


				const ffontLoader = new THREE.FontLoader();

				ffontLoader.load( 'fonts/helvetiker_bold.typeface.json', function ( font ) {
						let textgeometry = new THREE.TextGeometry( '3duno', {
							font: font,
							size: 10,
							height: 2,
							curveSegments: 2,
							bevelEnabled: true,
							bevelThickness: 1,
							bevelSize: 0.5,
							bevelOffset: 0,
							bevelSegments: 2
						} );
						const textobject = new THREE.Mesh( textgeometry, new THREE.MeshLambertMaterial( { color: 0xffffff } ) );
						textobject.position.z = 15
						textobject.position.x = -20
						textobject.position.y = -5
						scene.add( textobject );
				} );


				// const textgeometry = new THREE.TextGeometry( 1, 1, 1 );
				for ( let i = 0; i < 12; i ++ ) {
					const geometry = new THREE.BoxGeometry( 5, 2, 0.5+i/3 );

					const object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial({ wireframe: colors[i].wireframe, map: THREE.ImageUtils.loadTexture(`./img/grad${i+1}.jpg`) }) );

					object.position.z = (-90*i);
					object.position.y = -i
					// object.position.x = Math.sin(i)*25;
					// object.position.z = Math.cos(i)*180;
					// object.position.z = -Math.sin(i)*40;
					// object.position.x = Math.sin(i)*75;
					// object.rotation.y = Math.random() * 0.4 * Math.PI + 0.1;
					// object.scale.y = (i * 0.2) + 1;
					object.scale.x = 10
					object.scale.y = 10 - i*2 < 1 ? 1 : 10 - i*2
					object.scale.z = 10


					scene.add( object );

				}

				raycaster = new THREE.Raycaster();

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );



				document.addEventListener( 'mousemove', onPointerMove );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onPointerMove( event ) {

				pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			//

			function animate() {
				totalTimeElapsed += 1
				requestAnimationFrame( animate );

				render();
			}

			function render() {
				if (orange)
				{
					let asd = parseInt(INTERSECTED.id)
					// camera.position.set( INTERSECTED.position  );

					// camera.position.x = INTERSECTED.position.x
					// camera.lookAt( INTERSECTED.position );
					// camera.position.z = 50
					// camera.position.y = 20
					orangeLevel += asd
					orangeDOM.innerHTML = orangeLevel
				} else {
					// camera.position.x = scene.position.x
					// camera.lookAt( scene.position );
				}

				theta += tRate;
				tRate += 0.0001;

				// camera.position.x = radius * Math.sin( THREE.MathUtils.degToRad( theta ) );
				// camera.lookAt( scene.position );

				camera.updateMatrixWorld();

				// find intersections

				if (INTERSECTED && INTERSECTED.position.y < 0)
				{

					// INTERSECTED.position.y = INTERSECTED.position.y < 0 ? INTERSECTED.position.y + 0.2  : 0
				}

				raycaster.setFromCamera( pointer, camera );

				const intersects = raycaster.intersectObjects( scene.children, false );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED )
						{
							INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
						}

						INTERSECTED = intersects[ 0 ].object;
						if (INTERSECTED.id > 10 && INTERSECTED.id <= 21)
						{
							orange = true
						}
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0x550000 );

					}

				} else {

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					if (orange)
					{
						orangeLevel -= parseInt(orangeLevel / 2)
						orangeDOM.innerHTML = orangeLevel
					}
					orange = false
					
					INTERSECTED = null;

				}

					if (SELECTED) {
                        light.position.z = lerp(light.position.z,SELECTED.position.z,0.01)

						// camera.position.y = SELECTED.position.y + 15 
						// camera.position.y = lerp(
						// 	camera.position.y,
						// 	SELECTED.position.y + 15,
						// 	0.5) + Math.sin(totalTimeElapsed/20)/80
						// camera.position.z = SELECTED.position.z + 90
						camera.position.z = lerp(
							camera.position.z,
							SELECTED.position.z + 26+(colors[-(SELECTED.position.z/90)] ? colors[-(SELECTED.position.z/90)].camera.pos[2]:0 ),
							0.25)
						if (colors[-(SELECTED.position.z/90)])
						{
							// if (colors[-(SELECTED.position.z/90)].camera.pos)
							// {
							// 	console.log(colors[-(SELECTED.position.z/90)].camera.pos)
							// }
                            camera.position.x = lerp(camera.position.x ,colors[-(SELECTED.position.z/90)].camera.pos[0],.05)
                            camera.position.y = lerp(camera.position.y ,colors[-(SELECTED.position.z/90)].camera.pos[1],.05)
						}
						camera.lookAt( SELECTED.position.x, SELECTED.position.y-10, SELECTED.position.z   );
					} else {
					}
						camera.position.y = camera.position.y+ Math.sin(totalTimeElapsed/20)/80
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>